<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPFS Pad</title>

    <style>
        [v-cloak] {display: none;}

        .options {
            margin: 4px;
        }

        #mdInput, #mdOutput, .options {
            font-family: 'Courier New', Courier, monospace;
        }
        #mdInput {
            width: 100%
        }

    </style>
</head>

<body>
    <div id="app" v-cloak>
        <button class="options">Share</button>

        <button @click="encryptData" class="options">Encrypt</button>
        <button @click="decryptData" class="options">Decrypt</button>

        <a href="#" class="options">about</a>
        <hr>
        
        <div class="markdown-input-and-output">
            <textarea id="mdInput" v-model="plainText" :placeholder="guide" rows='18' style="border: none; outline: none;"></textarea>
            <div id="mdOutput" v-html="renderedHTML"></div>
            <p>{{ encData }}</p>
        </div>

    </div>
</body>
</html>

<script src="https://unpkg.com/vue@3"></script>
<script src="https://cdn.jsdelivr.net/remarkable/1.7.1/remarkable.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js"></script>

<script>
var md = new Remarkable()

const app = Vue.createApp({
    data() {
        return {
            guide: `Welcome to IPFS pad - a note taking and sharing application that uses the decentralised IPFS system to store your content.
            \nTry writing markdown here, and see it being rendered live below!
            \n\nThis text will disappear once you start typing.`,

            showMarkdownRender: true,


            plainText: "",
            password: "123#$%",
            encryptedObj: {},
        };
    },

    methods: {
        encryptData() {
            if (this.plainText.length) {
                // // hash the name with any algorithm
                // const data = CryptoJS.AES.encrypt(this.plaintext, this.secret).toString();

                // // store into localStorage
                // localStorage.setItem("secretData", data);

                // // display the encrypted data
                // this.getEncryptedData();

                const salt = CryptoJS.lib.WordArray.random(16)
                const iv = CryptoJS.lib.WordArray.random(16)

                const key = CryptoJS.PBKDF2(this.password, salt, { keySize: 256/32, iterations: 10000, hasher: CryptoJS.algo.SHA256})

                const encrypted = CryptoJS.AES.encrypt(this.plainText, key, {iv: iv}).ciphertext

                const concatenned =  CryptoJS.lib.WordArray.create().concat(salt).concat(iv).concat(encrypted)

                this.encryptedObj = {
                    iv: iv.toString(CryptoJS.enc.Base64),
                    salt: salt.toString(CryptoJS.enc.Base64),
                    encrypted: encrypted.toString(CryptoJS.enc.Base64),
                    concatenned: concatenned.toString(CryptoJS.enc.Base64)
                }

                console.log(this.encryptedObj)
            }
        },

        decryptData() {
            // // get data from localStorage
            // const secretData = localStorage.getItem("secretData");

            // // decrypt the data and convert to string
            // const decryptData = CryptoJS.AES.decrypt(
            //     secretData,
            //     this.secret
            // );//.toString(CryptoJS.enc.Utf8);

            // localStorage.setItem("dData", decryptData);

            // alert("Decrypted private data: " + decryptData);

            const encrypted =  CryptoJS.enc.Base64.parse(this.encryptedObj.concatenned);

            const salt_len = iv_len = 16;

            const salt = CryptoJS.lib.WordArray.create(
                encrypted.words.slice(0, salt_len / 4 )
            );
            
            const iv = CryptoJS.lib.WordArray.create(
                encrypted.words.slice(0 + salt_len / 4, (salt_len+iv_len) / 4 )
            );

            const key = CryptoJS.PBKDF2(
                this.password,
                salt,
                { keySize: 256/32, iterations: 10000, hasher: CryptoJS.algo.SHA256}
            );

            const decrypted = CryptoJS.AES.decrypt(
                {
                    ciphertext: CryptoJS.lib.WordArray.create(
                        encrypted.words.slice((salt_len + iv_len) / 4)
                    )
                },
                key,
                {iv: iv}
            );

            console.log(decrypted.toString(CryptoJS.enc.Utf8));
        },

        deleteData() {
            // // remove data from localStorage
            // plaintext =  " "; 
            // localStorage.removeItem("secretData");

            // // update text
            // this.getEncryptedData();
            // },

            // getEncryptedData() {
            // // get the data from localStorage or send placeholder text
            // this.encData = localStorage.getItem("secretData") || "No value present";
        },
    },

    computed: {
        renderedHTML() {
            if (this.showMarkdownRender) {
                return md.render(this.plainText)
            }
        }
    },

    mounted() {
        // code to run after initialization
    },
})



app.mount('#app')
</script>
